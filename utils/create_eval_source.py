# - Read the list of fitted primitives (.fit file)
# - Read the expression generated by the GP (a regular .txt file)
# - Read the original point-set (.xyzn) - we need to get the bounding box in order to clamp the object (i.e. take its intersection with the bounding box)
# - Generate a .cpp file with the read expression and fitted primitives in eval()


import sys
import re
import point_set


def read_fit(fit_filename):
    '''
    Create a list of primitives from the a file. 
    A primitive is a list made of:
    name, type, parameter1, parameter2, ...
    where: name is a string, type is a string, parameters are float
    '''

    f = open(fit_filename)

    list_primitives = []
    count = 0

    for line in f:
        elements = line.strip().split()
        if len(elements)==0:
            continue

        prim_type = elements[0]
        parameters = []
        for i in range(1, len(elements)):
            parameters.append(float(elements[i]))

        primitive = []
        prim_name = prim_type + str(count)
        primitive.append(prim_name)
        primitive.append(prim_type)
        for parameter in parameters:
            primitive.append(parameter)

        count = count + 1

        list_primitives.append(primitive)

    f.close()
    return list_primitives


def read_expression(exp_filename):
    f = open(exp_filename)
    line = f.readline()
    line = line.strip()
    f.close()
    return line


def create_eval_cpp(prim_list, expression, cpp_filename, bbox=None):
    f = open(cpp_filename, "w")
    
    f.write('#include "operations.h"\n')
    f.write('#include "primitives.h"\n')
    f.write('\n')
    f.write('double eval(double x, double y, double z) {')
    f.write('\n')
    # generate the list of primitives
    # one local variable for each instantiated primitive
    for prim in prim_list:
        name = prim[0]
        prim_type = prim[1]
        # the parameters 
        f.write('double %s_parameters[] = ' % name)
        f.write('{')
        # write the numerical values of the parameters
        for i in range(2, len(prim)-1):
            f.write(str(prim[i])+',')
        f.write(str(prim[-1]))
        f.write('};\n')
        # the primitive 
        f.write('double %s = ' % name)
        f.write('primitive_%s' % prim_type)
        f.write('(x,y,z,%s_parameters);\n' % name)

    # replace union, ... by set_union, ... in expression
    cpp_expression = expression
    cpp_expression = re.sub('union', 'set_union', cpp_expression)
    cpp_expression = re.sub('subtraction', 'set_subtraction', cpp_expression)
    cpp_expression = re.sub('negation', 'set_negation', cpp_expression)
    cpp_expression = re.sub('intersection', 'set_intersection', cpp_expression)
    
    # replace [] by () for the function call symbols
    # [ and ] need to be escaped but not ( and )
    cpp_expression = re.sub('\[', '(', cpp_expression)
    cpp_expression = re.sub('\]', ')', cpp_expression)

    f.write('double model = %s;\n' % cpp_expression)

    # if bbox is not None then take the intersection of model with the 
    # bounding box
    if bbox is not None:
        pt_min, pt_max = bbox
        x_min,y_min,z_min = pt_min
        x_max,y_max,z_max = pt_max
        f.write('double bbox = set_intersection(x ')
        if x_min < 0:
            f.write(' + %s, ' % str(abs(x_min)))
        else:
            f.write(' - %s, ' % str(x_min))
        f.write(' %s - x);\n' % str(x_max))

        f.write('bbox = set_intersection(bbox, y')
        if y_min < 0:
            f.write(' + %s);\n' % str(abs(y_min)))
        else:
            f.write(' - %s);\n' % str(y_min))
        f.write('bbox = set_intersection(bbox, %s - y);\n' % str(y_max))

        f.write('bbox = set_intersection(bbox, z')
        if z_min < 0:
            f.write(' + %s);\n' % str(abs(z_min)))
        else:
            f.write(' - %s);\n' % str(z_min))
        f.write('bbox = set_intersection(bbox, %s - z);\n' % str(z_max))

        f.write('model = set_intersection(model, bbox);\n')

    f.write('return model;\n')

    f.write('}\n')

    f.close()


def main(fit_filename, exp_filename, cpp_filename, ps_filename = ''):
    prim_list = read_fit(fit_filename)
    expression = read_expression(exp_filename)
    if ps_filename == '':
        create_eval_cpp(prim_list, expression, cpp_filename)
    else:
        ps = point_set.read_point_set(ps_filename)
        bbox = point_set.compute_bounding_box(ps)
        create_eval_cpp(prim_list, expression, cpp_filename, bbox)


def usage(progname):
    print('Usage: ')
    print(progname + ' model.fit model.txt model.cpp [model.xyzn]')
    print('Where:')
    print('\t model.fit: a file containing a list of fitted primitives')
    print('\t model.txt: a file containing an expression for the object')
    print('\t model.cpp: the generated c++ file corresponding to the expression')
    print('\t model.xyzn: a file containing the list of points sampled on the model (optional).')


if __name__ == '__main__':
    num_args = len(sys.argv)
    if num_args != 4 and num_args != 5:
        usage(sys.argv[0])
        sys.exit(1)

    fit_filename = sys.argv[1]
    exp_filename = sys.argv[2]
    cpp_filename = sys.argv[3]
    if num_args == 5:
        ps_filename = sys.argv[4]
        main(fit_filename, exp_filename, cpp_filename, ps_filename)
    else:
        main(fit_filename, exp_filename, cpp_filename)

